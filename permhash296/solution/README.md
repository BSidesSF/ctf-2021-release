The first thing to do is to translate the permutations to something
GAP understands.

GAP lists are 1-indexed and Go is 0-indexed which can be handled
easily. Also the permutation is inverted so to get back the original
permutation the result must be inverted again:

```
gap> PermList(List([63, 62, 40, 42, 34, 32, 61, 22, 27, 28, 23, 10, 29, 45, 5, 19, 16, 24, 46, 33, 17, 14, 8, 47, 18, 44, 25, 26, 53, 38, 21, 52, 15, 1, 31, 0, 59, 36, 56, 6, 37, 41, 58, 51, 54, 11, 2, 50, 55, 4, 12, 39, 35, 13, 43, 3, 30, 7, 9, 48, 57, 60, 20, 49], i -> i + 1))^-1;
(1,36,53,32,35,5,50,64)(2,34,20,16,33,6,15,22,31,57,39,30,13,51,48,24,11,12,46,14,54,29,10,59,43,4,56,49,60,37,38,41,3,47,19,25,18,
21,63)(7,40,52,44,55,45,26,27,28,9,23,8,58,61,62)
```

This can be done for each of the 16 generators and the finalization
permutation.

Once all 16 are loaded up things like their Orders can be determined:

```
gap> List(gens, Order);
[ 1560, 714, 462, 3465, 3990, 1484, 40, 836, 114, 2064, 918, 910, 440, 260, 3600, 56 ]
```

Gen 0x6 has order 40 which can be used to generate trivial collisions
by inserting `\x66` 20 times anywhere into an input string.

To do more sophisticated things useful 'tools' (relationships between
generators) must be found.  All lengeth 2 and 3 squences with small order:

```
gap> for i in [1 .. Length(gens)] do
>       for j in [1 .. Length(gens)] do
>               p := gens[i] * gens[j];
>               ord := Order(p);
>               if ord <= 8 then
>                       Print(i, ",", j, " has small order ", ord, ": ", p, "\n");
>               fi;
>               for k in [1 .. Length(gens)] do
>                       p := gens[i] * gens[j] * gens[k];
>                       ord := Order(p);
>                       if ord <= 8 then
>                               Print(i, ",", j, ",", k, " has small order ", ord, ": ", p, "\n");
>                       fi;
>               od;
>       od;
> od;
3,4,4 has small order 2: (1,2)
4,3,4 has small order 2: ( 7,59)
4,4,3 has small order 2: (23,33)
5,6,7 has small order 1: ()
6,7,5 has small order 1: ()
7,5,6 has small order 1: ()
9,10 has small order 8: ( 1, 9,17,25,33,41,49,57)( 2,10,18,26,34,42,50,58)( 3,11,19,27,35,43,51,59)( 4,12,20,28,36,44,52,60)( 5,13,21,29,37,45,53,61)( 6,14,22,30,38,46,54,62)( 7,15,23,31,39,47,55,63)( 8,16,24,32,40,48,56,64)
10,9 has small order 8: ( 1,35,36,24,26,13,62, 6)( 2,61,63,34,20,53,54,44)( 3,46,23,64,21,42,19,52)( 4,16,57,29, 8,18,32,59)( 5,33,51, 9,60,45,15,40)( 7,56,49,10,48,38,47,30)(11,28,37,41,58,43,55,27)(12,17,39,14,50,25,22,31)
11,12 has small order 2: ( 1,33)( 2,34)( 3,35)( 4,36)( 5,37)( 6,38)( 7,39)( 8,40)( 9,41)(10,42)(11,43)(12,44)(13,45)(14,46)(15,47)(16,48)(17,49)(18,50)(19,51)(20,52)(21,53)(22,54)(23,55)(24,56)(25,57)(26,58)(27,59)(28,60)(29,61)(30,62)(31,63)(32,64)
12,11 has small order 2: ( 1,50)( 2,61)( 3,57)( 4,28)( 5,33)( 6,16)( 7,46)( 8,56)( 9,14)(10,53)(11,39)(12,43)(13,15)(17,26)(18,21)(19,54)(20,32)(22,45)(23,37)(24,30)(25,59)(27,55)(29,41)(31,60)(34,44)(35,38)(36,49)(40,42)(47,62)(48,63)(51,52)(58,64)
```

Note these generators are 1-based and the hex is 0-based. The `\x233`
sequence is exceptionally useful because it swaps an adjacent pair.
Also note that the `\x89` sequence rotates the whole state by 8.

`\x456` (and variants `\x564` and `\x645`) are much shorter identity
sequences for making much shorter collisions.

It would be very useful to look for other state rotations:

Length 2 rotations:

```
gap> rot := ( 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64);
gap> for i in [1 .. Length(gens)] do
>       for j in [1 .. Length(gens)] do
>
>                       for e in [1 .. 63] do
>                               p := gens[i] * gens[j];
>                               if p = rot^e then
>                                       Print(i, ",", j, " is rotation by ", e, " ", p, "\n");
>                               fi;
>                       od;
>       od;
> od;
9,10 is rotation by 8 ( 1, 9,17,25,33,41,49,57)( 2,10,18,26,34,42,50,58)( 3,11,19,27,35,43,51,59)( 4,12,20,28,36,44,52,60)( 5,13,21,29,37,45,53,61)( 6,14,22,30,38,46,54,62)( 7,15,23,31,39,47,55,63)( 8,16,24,32,40,48,56,64)
11,12 is rotation by 32 ( 1,33)( 2,34)( 3,35)( 4,36)( 5,37)( 6,38)( 7,39)( 8,40)( 9,41)(10,42)(11,43)(12,44)(13,45)(14,46)(15,47)(16,48)(17,49)(18,50)(19,51)(20,52)(21,53)(22,54)(23,55)(24,56)(25,57)(26,58)(27,59)(28,60)(29,61)(30,62)(31,63)(32,64)
```


Length 3 rotations:

```
gap> rot := ( 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64);
gap> for i in [1 .. Length(gens)] do
>       for j in [1 .. Length(gens)] do
>               for k in [1 .. Length(gens)] do
>                       for e in [1 .. 63] do
>                               p := gens[i] * gens[j] * gens[k];
>                               if p = rot^e then
>                                       Print(i, ",", j, ",", k, " is rotation by ", e, " ", p, "\n");
>                               fi;
>                       od;
>               od;
>       od;
> od;
1,2,2 is rotation by 1 ( 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64)
```

Also note that randomly trying short sequences will find tons of
64-cycles and any of those combined with a swap like `\x233` are
sufficient for arbitrary state manipulation. The `\x011` happens to be
exceptionally convienient for human use.


== Challenge 1 ==

Please compute the hash of 6f57dab3fbf1d1e6
permhash296?

PermCoin Hacktool> hash 6f57dab3fbf1d1e6
2a8140e9ff63ee805f8cd130f95bff8c47f46aefe8a29a1fa16642b649ea718eacff72a713

permhash296? 2a8140e9ff63ee805f8cd130f95bff8c47f46aefe8a29a1fa16642b649ea718eacff72a713

Challenge 1 complete!


== Challenge 2 ==

Please enter message 1: 0456
Message 1's permhash296 is 85fd2d546531ce9a74dc253d551630722284ddf505746da24270ec2be4dbfb2fa580401000

Please enter message 2 (this must hash to the same thing as message 1): 4560
Message 2's permhash296 is 85fd2d546531ce9a74dc253d551630722284ddf505746da24270ec2be4dbfb2fa580401000

Challenge 2 complete!


== Challenge 3 ==

The empty-string hash: 4eeab86b437733ccd24f37aea5b5c37a690a4326fc84ee183a18a20710e5a253181c94e452

Please another message that collides with the empty-string: 456456
Your input's permhash296 is 4eeab86b437733ccd24f37aea5b5c37a690a4326fc84ee183a18a20710e5a253181c94e452

Challenge 3 complete!

PermCoin Hacktool> attack starter

Challenge 1 complete, hash computations computing!

Challenge 2 complete, collisions colliding!

Challenge 3 complete, empty strings emptying!

Starter attack complete!
easy flag here


== Challenge 4 ==

The intermediate hash broadcast through the network was dc40b9e8b1bcc54733ed7cbdf868bd3255a6bdae82077d41d288d4d1d33d0953df2c25e908
We need you to compute a new intemediate hash after d44c4a18f7e8aa34 has been appended to the hidden plaintext.

What is the new length-extended hash?


Get state from hash:
[55, 15, 43, 3, 25, 60, 45, 42, 31, 52, 7, 57, 17, 23, 44, 62, 16, 41, 1, 59, 28, 26, 56, 46, 12, 27, 4, 61, 18, 35, 53, 2, 34, 19, 29, 47, 40, 0, 48, 39, 50, 5, 49, 37, 36, 58, 11, 24, 21, 9, 10, 6, 14, 51, 32, 20, 8, 38, 30, 54, 33, 63, 13, 22]

Load into GAP:
gap> state := PermList(List([55, 15, 43, 3, 25, 60, 45, 42, 31, 52, 7, 57, 17, 23, 44, 62, 16, 41, 1, 59, 28, 26, 56, 46, 12, 27, 4, 61, 18, 35, 53, 2, 34, 19, 29, 47, 40, 0, 48, 39, 50, 5, 49, 37, 36, 58, 11, 24, 21, 9, 10, 6, 14, 51, 32, 20, 8, 38, 30, 54, 33, 63, 13, 22], i -> i + 1))^-1;
(1,38,44,3,32,9,57,23,64,62,28,26,5,27,22,49,39,58,12,47,24,14,63,16,2,19,29,21,56)(6,42,18,13,25,48,36,30,35,33,55,60,20,34,61)(7,52,54,31,59,46)(8,11,51,41,37,45,15,53,10,50,43)

Apply inverse final perm, then appended perms, then final perm, back to state:

gap> List(Permuted([1 .. 64], state * final^-1 * gens[14] * gens[5] * gens[5]* gens[13] * gens[5] * gens[11] * gens[2] * gens[9] * gens[16] * gens[8] * gens[15] * gens[9] * gens[11] * gens[11] * gens[4] * gens[5] * final), i -> i - 1);
[ 55, 49, 7, 3, 54, 63, 0, 28, 33, 42, 16, 26, 44, 1, 20, 22, 29, 11, 56, 32, 5, 36, 23, 50, 51, 8, 62, 6, 10, 12, 60, 17, 58, 34, 47, 57, 19, 18, 45, 52, 27, 46, 48, 61, 41, 38, 31, 4, 37, 35, 24, 53, 9, 40, 59, 25, 43, 39, 15, 13, 14, 21, 2, 30 ]

Get hash from state: de5e5c7f04b2ce0817710e0b7ec213bd1af3041854d7793683ae9936a911f7115f6a268638

What is the new length-extended hash? de5e5c7f04b2ce0817710e0b7ec213bd1af3041854d7793683ae9936a911f7115f6a268638

Challenge 4 complete!


== Challenge 5 ==

Please enter message 1 (max 8 bytes): 0456
Message 1's permhash296 is 85fd2d546531ce9a74dc253d551630722284ddf505746da24270ec2be4dbfb2fa580401000

Please enter message 2 (length 2 bytes): 4560
Message 2's permhash296 is 85fd2d546531ce9a74dc253d551630722284ddf505746da24270ec2be4dbfb2fa580401000

Challenge 5 complete!

== Challenge 6 ==

Please compute a pre-image for the hash 8f26a97359fdf5f08d06df5066e9a3597bb0b082b37244a5b006bb9ddc31eefebb57b08d57
pre-image?

Convert hash to state:
[35, 58, 14, 18, 23, 47, 17, 22, 11, 28, 40, 31, 45, 37, 60, 29, 15, 62, 24, 20, 1, 4, 10, 49, 34, 27, 42, 50, 25, 41, 54, 5, 32, 57, 8, 39, 38, 6, 7, 30, 63, 12, 36, 3, 46, 61, 2, 56, 59, 44, 16, 53, 21, 9, 51, 19, 13, 0, 43, 48, 33, 26, 55, 52]

Load state into GAP to apply the inverse final perm:
gap> state := PermList(List([35, 58, 14, 18, 23, 47, 17, 22, 11, 28, 40, 31, 45, 37, 60, 29, 15, 62, 24, 20, 1, 4, 10, 49, 34, 27, 42, 50, 25, 41, 54, 5, 32, 57, 8, 39, 38, 6, 7, 30, 63, 12, 36, 3, 46, 61, 2, 56, 59, 44, 16, 53, 21, 9, 51, 19, 13, 0, 43, 48, 33, 26, 55, 52], i -> i + 1))^-1;
(1,58,34,61,15,3,47,45,50,24,5,22,53,64,41,11,23,8,39,37,43,27,62,46,13,42,30,16,17,51,28,26,29,10,54,52,55,31,40,36)(2,21,20,56,63,18,7,38,14,57,48,6,32,12,9,35,25,19,4,44,59)(49,60)
gap> List(Permuted([1 .. 64], state * final^-1), i -> i - 1);
[ 34, 1, 2, 31, 19, 53, 12, 4, 14, 3, 18, 30, 56, 7, 6, 28, 24, 50, 8, 35, 40, 55, 16, 51, 42, 33, 43, 59, 25, 49, 36, 10, 52, 23, 62, 27, 0, 32, 9, 38, 47, 45, 41, 11, 48, 61, 29, 26, 57, 54, 21, 58, 5, 44, 20, 39, 37, 63, 46, 17, 15, 22, 60, 13 ]


Load goal state into solver:

my @state = (0 .. ($N - 1));
my @goal = (34, 1, 2, 31, 19, 53, 12, 4, 14, 3, 18, 30, 56, 7, 6, 28, 24, 50, 8, 35, 40, 55, 16, 51, 42, 33, 43, 59, 25, 49, 36, 10, 52, 23, 62, 27, 0, 32, 9, 38, 47, 45, 41, 11, 48, 61, 29, 26, 57, 54, 21, 58, 5, 44, 20, 39, 37, 63, 46, 17, 15, 22, 60, 13);


Length 739 solution found:
898989332DDCD011CBDDCDDDDC011233DDCD011CDDDDDCD011323233332011011233332DDCDDDDC011EFFEFFEFFDDCD011EFFEFFEFFEFFEFFEFFDDCD011EFFEFFEFFEFFEFF233011233332011011011CDDD233DDCD011DCDDDDCDDDDC011233332011EFFEFFEFFEFF332DDDC011CDDD233011233332011233332011233332011CDDD233332011233332011DCDD233332DDCD011233332DDCD011CDDD332DDCD011332DDCDDDDC011332011332DDCD011233DDCD011233332011DCDD233011233011233011233011233DDCD011233332DDCD011233332011233011323233011332011011332011233332DDDC011233332011233332DDCD011898989011011011011011011233DDDC011233332011011011DCDD332011233332011233011233011233332011EFFEFFEFFEFF332011011011011EFFEFFEFF332011DCDD233332011DCDD332DDDC011DCDD2333320118989011233011EFFEFFEFF233011233011233011233011EFFEFFEFFEFF011233332011011011233011EFFEFFEFFEFF332011332011233011EFFEFFEFFEFFEFFEFF01101123301133289233011233011233011011233011EFFEFFEFF011011011EFFEFFEFFEFFEFF01101101123389233011011233011011233011EFFEFFEFFEFFEFFEFF011DCDD011EFF011EFFEFFEFFEFF8923389011011233011233011011011011233011011233011011011011233011EFFEFFEFFEFF011011233011011EFFEFFEFFEFF01101123301101123301101101101101123301123389011011233011011011233011EFFEFFEFF011EFF8901101123301123301101101101123301101123301101101101123301101123301101123389EFFEFFEFFEFFEFFEFF011011011011233011233898901123389890112330110112330110110110110110112330110112338901123389011233011233AB0110112330110112330110110110110110112338901101101123389011233011233AB890110112338989011011011011011233AB89011011233AB8989011011011011011

pre-image? 898989332DDCD011CBDDCDDDDC011233DDCD011CDDDDDCD011323233332011011233332DDCDDDDC011EFFEFFEFFDDCD011EFFEFFEFFEFFEFFEFFDDCD011EFFEFFEFFEFFEFF233011233332011011011CDDD233DDCD011DCDDDDCDDDDC011233332011EFFEFFEFFEFF332DDDC011CDDD233011233332011233332011233332011CDDD233332011233332011DCDD233332DDCD011233332DDCD011CDDD332DDCD011332DDCDDDDC011332011332DDCD011233DDCD011233332011DCDD233011233011233011233011233DDCD011233332DDCD011233332011233011323233011332011011332011233332DDDC011233332011233332DDCD011898989011011011011011011233DDDC011233332011011011DCDD332011233332011233011233011233332011EFFEFFEFFEFF332011011011011EFFEFFEFF332011DCDD233332011DCDD332DDDC011DCDD2333320118989011233011EFFEFFEFF233011233011233011233011EFFEFFEFFEFF011233332011011011233011EFFEFFEFFEFF332011332011233011EFFEFFEFFEFFEFFEFF01101123301133289233011233011233011011233011EFFEFFEFF011011011EFFEFFEFFEFFEFF01101101123389233011011233011011233011EFFEFFEFFEFFEFFEFF011DCDD011EFF011EFFEFFEFFEFF8923389011011233011233011011011011233011011233011011011011233011EFFEFFEFFEFF011011233011011EFFEFFEFFEFF01101123301101123301101101101101123301123389011011233011011011233011EFFEFFEFF011EFF8901101123301123301101101101123301101123301101101101123301101123301101123389EFFEFFEFFEFFEFFEFF011011011011233011233898901123389890112330110112330110110110110110112330110112338901123389011233011233AB0110112330110112330110110110110110112338901101101123389011233011233AB890110112338989011011011011011233AB89011011233AB8989011011011011011

Challenge 6 complete!


== Challenge 7 ==

We've found two 20-byte prefixes.
Prefix 1: 3cf559db9f228742b050661ed8115d5c6bffb644
Prefix 2: 993ed42a5196e579deead9e747e87a904fa6a373

Please find two messages to append, one to prefix 1,
and the other to prefix 2, such that the permhhash296 is the same for both.


Append empty string to prefix 1:
PermCoin Hacktool> hash 3cf559db9f228742b050661ed8115d5c6bffb644
f2c423663e11a11990bc114269f4ea47681f721f6c92f9b9e6881f5fb8e5429852553b1942

Now prefix 2's state must be steered to that hash.

Get intemediate state from prefix 2:

phash.Init()
phash.Update(hex_to_bytes("3cf559db9f228742b050661ed8115d5c6bffb644"))
fmt.Printf("Intermediate state 1: %v\n", phash.State)

phash.Init()
phash.Update(hex_to_bytes("993ed42a5196e579deead9e747e87a904fa6a373"))
fmt.Printf("Intermediate state 2: %v\n", phash.State)

Intermediate state 1: [63, 24, 42, 31, 50, 25, 21, 33, 28, 5, 27, 61, 8, 38, 15, 13, 54, 41, 58, 60, 55, 32, 44, 34, 0, 46, 10, 30, 3, 49, 52, 48, 36, 4, 47, 53, 14, 35, 37, 23, 22, 57, 59, 9, 20, 7, 62, 2, 16, 11, 6, 56, 29, 43, 18, 51, 19, 17, 39, 12, 26, 45, 40, 1]
Intermediate state 2: [21, 58, 29, 2, 22, 51, 4, 27, 20, 10, 7, 1, 13, 16, 17, 18, 12, 38, 14, 44, 40, 34, 3, 8, 60, 39, 56, 15, 33, 19, 0, 25, 47, 28, 59, 41, 42, 32, 50, 57, 36, 62, 52, 37, 54, 55, 26, 35, 31, 5, 6, 45, 61, 46, 9, 48, 23, 53, 43, 49, 30, 11, 63, 24]

Now steer state 2 to 1 with solver:

my @state = (21, 58, 29, 2, 22, 51, 4, 27, 20, 10, 7, 1, 13, 16, 17, 18, 12, 38, 14, 44, 40, 34, 3, 8, 60, 39, 56, 15, 33, 19, 0, 25, 47, 28, 59, 41, 42, 32, 50, 57, 36, 62, 52, 37, 54, 55, 26, 35, 31, 5, 6, 45, 61, 46, 9, 48, 23, 53, 43, 49, 30, 11, 63, 24);
my @goal = (63, 24, 42, 31, 50, 25, 21, 33, 28, 5, 27, 61, 8, 38, 15, 13, 54, 41, 58, 60, 55, 32, 44, 34, 0, 46, 10, 30, 3, 49, 52, 48, 36, 4, 47, 53, 14, 35, 37, 23, 22, 57, 59, 9, 20, 7, 62, 2, 16, 11, 6, 56, 29, 43, 18, 51, 19, 17, 39, 12, 26, 45, 40, 1);

Length 764 solution found:
8989011233332DDCDDDDC011DCDD233DDDC011011332DDCDDDDC011DCDD233DDCD011233DDCD011233DDCD011233DDCD011233DDCD011DCDDDDCD011233DDCD011233011233DDCD011233DDDC011233011233011233011233011233332011233332011233DDDC011233DDDC011233332011233011233DDCDDDDC011233011233332011233332011233011233332DDCDDDDC011323233011233332011233332011011233332DDDC011233332011CDDD233332DDCD011EFFEFFEFF233332DDDC011011011332DDDC011233332011233332DDCD011DCDD233332DDDC011332011332DDCD011DDDC011011DDCD011332DDCD011233DDDC011DCDD233011AB898989011011011011011233011233011011233DDCD011EFFEFFEFF332011233DDDC011233332011233011233DDCD011233332011011233332011233332011233332011233011233011233011233011233011EFFEFFEFF011EFFEFFEFFEFFEFFEFFEFF332011011233332011233332011233011DCDD011DCDD233011233011233011233011233011332011233332011233011233011332011233332011233011233011EFFEFFEFFEFF011233011011233011011DCDD332011332011DCDD332011233011EFFEFFEFFEFF011AB233011EFFEFFEFFEFF01123301101123301101123301123301101101123301133201123333201123301123301123389EFFEFFEFFEFF011233011EFFEFFEFFEFFEFFEFF89EFFEFFEFFEFF011233011DCDD011233011EFF011EFFEFFEFF011EFF011011011233332011AB23389233011011EFFEFFEFFEFF011011011233011011233011011233011011233011233892330112330110110110112338923301123301123389011011233011011233011011011011233011EFFEFFEFFEFFEFFEFF011233011011011233011EFFEFFEFFEFF0112330110110110112338989233892330112330112338901101123301101123301101101101123301101101101101123389233011233AB0112338901101123301101123389011233AB8901101123389011011011011233AB898901101101123389011011

Append message 1 (limit 8172 bytes)?
Chosen prefix 1 + message 1 hash: f2c423663e11a11990bc114269f4ea47681f721f6c92f9b9e6881f5fb8e5429852553b1942

Append message 2 (limit 8172 bytes)? 8989011233332DDCDDDDC011DCDD233DDDC011011332DDCDDDDC011DCDD233DDCD011233DDCD011233DDCD011233DDCD011233DDCD011DCDDDDCD011233DDCD011233011233DDCD011233DDDC011233011233011233011233011233332011233332011233DDDC011233DDDC011233332011233011233DDCDDDDC011233011233332011233332011233011233332DDCDDDDC011323233011233332011233332011011233332DDDC011233332011CDDD233332DDCD011EFFEFFEFF233332DDDC011011011332DDDC011233332011233332DDCD011DCDD233332DDDC011332011332DDCD011DDDC011011DDCD011332DDCD011233DDDC011DCDD233011AB898989011011011011011233011233011011233DDCD011EFFEFFEFF332011233DDDC011233332011233011233DDCD011233332011011233332011233332011233332011233011233011233011233011233011EFFEFFEFF011EFFEFFEFFEFFEFFEFFEFF332011011233332011233332011233011DCDD011DCDD233011233011233011233011233011332011233332011233011233011332011233332011233011233011EFFEFFEFFEFF011233011011233011011DCDD332011332011DCDD332011233011EFFEFFEFFEFF011AB233011EFFEFFEFFEFF01123301101123301101123301123301101101123301133201123333201123301123301123389EFFEFFEFFEFF011233011EFFEFFEFFEFFEFFEFF89EFFEFFEFFEFF011233011DCDD011233011EFF011EFFEFFEFF011EFF011011011233332011AB23389233011011EFFEFFEFFEFF011011011233011011233011011233011011233011233892330112330110110110112338923301123301123389011011233011011233011011011011233011EFFEFFEFFEFFEFFEFF011233011011011233011EFFEFFEFFEFF0112330110110110112338989233892330112330112338901101123301101123301101101101123301101101101101123389233011233AB0112338901101123301101123389011233AB8901101123389011011011011233AB898901101101123389011011
Chosen prefix 2 + message 2 hash: f2c423663e11a11990bc114269f4ea47681f721f6c92f9b9e6881f5fb8e5429852553b1942

Challenge 7 complete!


== Challenge 8 ==

The intermediate hash so far is a5d40acd17f627344be15a6514fd37994425595492fed91a133d6b0a28c129689845018980
We need you to length-extend the plaintext for this hash with 1024 more bytes so that the new hash is 3c1f51683eb8d11bba9623eb2391e331bf095dee69dd7137625a7bf83980a279d9f68a54cb

Your found 1024-byte transaction?


State from hash: [41, 37, 38, 18, 11, 29, 25, 5, 58, 2, 53, 49, 7, 1, 16, 48, 43, 30, 61, 47, 35, 28, 42, 33, 46, 40, 50, 54, 45, 14, 31, 23, 51, 8, 4, 62, 13, 34, 9, 57, 39, 26, 22, 24, 15, 27, 0, 12, 20, 56, 59, 55, 6, 32, 3, 17, 52, 44, 60, 63, 21, 36, 10, 19]

Undo final perm with GAP:
gap> state := PermList(List([41, 37, 38, 18, 11, 29, 25, 5, 58, 2, 53, 49, 7, 1, 16, 48, 43, 30, 61, 47, 35, 28, 42, 33, 46, 40, 50, 54, 45, 14, 31, 23, 51, 8, 4, 62, 13, 34, 9, 57, 39, 26, 22, 24, 15, 27, 0, 12, 20, 56, 59, 55, 6, 32, 3, 17, 52, 44, 60, 63, 21, 36, 10, 19], i -> i + 1))^-1;
(1,47,25,44,17,15,30,6,8,13,48,20,64,60,51,27,42)(2,14,37,62,19,4,55,28,46,29,22,61,59,9,34,24,32,31,18,56,52,33,54,11,63,36,21,49,16,45,58,40,41,26,7,53,57,50,12,5,35,38)(3,10,39)(23,43)
gap> List(Permuted([1 .. 64], state * final^-1), i -> i - 1);
[ 46, 35, 0, 49, 17, 55, 26, 28, 38, 24, 18, 57, 12, 9, 34, 2, 61, 54, 4, 41, 53, 10, 59, 3, 50, 21, 60, 20, 45, 33, 22, 42, 19, 11, 30, 40, 44, 51, 32, 13, 29, 7, 14, 58, 63, 27, 48, 36, 8, 31, 6, 37, 23, 56, 47, 62, 1, 39, 15, 25, 43, 5, 16, 52 ]

Now do the same for the goal hash.
State from hash: [15, 5, 8, 27, 56, 50, 21, 3, 61, 12, 48, 14, 59, 33, 11, 38, 55, 35, 13, 63, 10, 17, 57, 34, 24, 18, 40, 52, 6, 32, 39, 46, 45, 29, 23, 43, 31, 22, 28, 9, 60, 42, 2, 44, 54, 51, 20, 0, 36, 62, 58, 1, 47, 16, 25, 53, 4, 19, 49, 26, 30, 41, 37, 7]

gap> state := PermList(List([15, 5, 8, 27, 56, 50, 21, 3, 61, 12, 48, 14, 59, 33, 11, 38, 55, 35, 13, 63, 10, 17, 57, 34, 24, 18, 40, 52, 6, 32, 39, 46, 45, 29, 23, 43, 31, 22, 28, 9, 60, 42, 2, 44, 54, 51, 20, 0, 36, 62, 58, 1, 47, 16, 25, 53, 4, 19, 49, 26, 30, 41, 37, 7], i -> i + 1))^-1;
(1,48,53,28,4,8,64,20,58,23,38,63,50,59,51,6,2,52,46,33,30,34,14,19,26,55,45,44,36,18,22,7,29,39,16)(3,43,42,62,9)(5,57)(10,40,31,61,41,27,60,13)(11,21,47,32,37,49)(12,15)(17,54,56)(24,35)
gap> List(Permuted([1 .. 64], state * final^-1), i -> i - 1);
[ 24, 10, 20, 14, 53, 1, 42, 17, 8, 44, 27, 9, 0, 28, 22, 12, 13, 52, 23, 15, 48, 37, 58, 25, 40, 30, 49, 36, 6, 34, 2, 57, 7, 56, 35, 18, 19, 45, 16, 31, 50, 59, 32, 61, 26, 51, 38, 41, 29, 39, 47, 5, 46, 62, 63, 43, 33, 60, 54, 21, 55, 3, 11, 4 ]


my @state = (46, 35, 0, 49, 17, 55, 26, 28, 38, 24, 18, 57, 12, 9, 34, 2, 61, 54, 4, 41, 53, 10, 59, 3, 50, 21, 60, 20, 45, 33, 22, 42, 19, 11, 30, 40, 44, 51, 32, 13, 29, 7, 14, 58, 63, 27, 48, 36, 8, 31, 6, 37, 23, 56, 47, 62, 1, 39, 15, 25, 43, 5, 16, 52);
my @goal = (24, 10, 20, 14, 53, 1, 42, 17, 8, 44, 27, 9, 0, 28, 22, 12, 13, 52, 23, 15, 48, 37, 58, 25, 40, 30, 49, 36, 6, 34, 2, 57, 7, 56, 35, 18, 19, 45, 16, 31, 50, 59, 32, 61, 26, 51, 38, 41, 29, 39, 47, 5, 46, 62, 63, 43, 33, 60, 54, 21, 55, 3, 11, 4);

Length 745 solution found:
98233332DDCDDDDC011AB8989011011011011011233DDCDDDDC011CDDD332DDDC011233DDCD011233DDDC011CDDD233011323233DDCD011233332DDDC011CDDD233332011233332011CDDD233011233011233332011323011233332011233332011233011332011233011CDDD332011DCDD233011332DDDC011233332DDCD011233DDCD011DCDD233332DDCD011233332DDDC011CDDD332011332011DCDD011DCDD332011DDCD011233332011EFF332DDCD011233011323233332011332DDCD011323233332011233011233332011323DDCD011233332011233011233332011233332011323233332011233011DCDD233DDCD011DCDDDDCD011233011233011DCDD233011233011EFFEFFEFFEFFEFFEFF01123301132323301123301123333201123301123301101123333201123301123301101123333201123301123301123301123333201123301123389233011233011233332011233011332011332011011DCDD011DDDC011332011AB89898923389DCDD233011233011332011233011AB8989011011011011011DDDC89EFF011AB8989011233332011233332011233011233011332011DCDD89DCDD233011011011011233011EFFEFFEFFEFFEFFEFF011011011011EFFEFFEFFEFFEFFEFF011EFFEFFEFFEFF233011011EFFEFFEFFEFF011EFFEFFEFF011AB898989011233011DCDD233011233011233011233011233011011EFFEFFEFFEFF011011011011233011011332011EFFEFFEFFEFF0112338901101123389233011233011233011233011233011233011011011EFFEFFEFFEFFEFFEFF011233011011011EFFEFFEFFEFF0112338923301123301123389233011EFFEFFEFFEFF011011011011DCDD011DCDD89011011011233011011EFFEFFEFF89233011233011233011233011011011011011EFFEFFEFF011233892330112338901101123301101123389890112330110110110112338901123389EFFEFFEFF89EFF89011011011233AB890112330112338989011011011011011233AB89011011233AB011011011


Must pad to 1024.  Add 456456 for +3 = 748.  Now add ABAB 138 times:
$ perl -e 'print "456456", ("ABAB" x 138), "\n";'
456456ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB


Your found 1024-byte transaction? 98233332DDCDDDDC011AB8989011011011011011233DDCDDDDC011CDDD332DDDC011233DDCD011233DDDC011CDDD233011323233DDCD011233332DDDC011CDDD233332011233332011CDDD233011233011233332011323011233332011233332011233011332011233011CDDD332011DCDD233011332DDDC011233332DDCD011233DDCD011DCDD233332DDCD011233332DDDC011CDDD332011332011DCDD011DCDD332011DDCD011233332011EFF332DDCD011233011323233332011332DDCD011323233332011233011233332011323DDCD011233332011233011233332011233332011323233332011233011DCDD233DDCD011DCDDDDCD011233011233011DCDD233011233011EFFEFFEFFEFFEFFEFF01123301132323301123301123333201123301123301101123333201123301123301101123333201123301123301123301123333201123301123389233011233011233332011233011332011332011011DCDD011DDDC011332011AB89898923389DCDD233011233011332011233011AB8989011011011011011DDDC89EFF011AB8989011233332011233332011233011233011332011DCDD89DCDD233011011011011233011EFFEFFEFFEFFEFFEFF011011011011EFFEFFEFFEFFEFFEFF011EFFEFFEFFEFF233011011EFFEFFEFFEFF011EFFEFFEFF011AB898989011233011DCDD233011233011233011233011233011011EFFEFFEFFEFF011011011011233011011332011EFFEFFEFFEFF0112338901101123389233011233011233011233011233011233011011011EFFEFFEFFEFFEFFEFF011233011011011EFFEFFEFFEFF0112338923301123301123389233011EFFEFFEFFEFF011011011011DCDD011DCDD89011011011233011011EFFEFFEFF89233011233011233011233011011011011011EFFEFFEFF011233892330112338901101123301101123389890112330110110110112338901123389EFFEFFEFF89EFF89011011011233AB890112330112338989011011011011011233AB89011011233AB011011011456456ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB

Challenge 8 complete!

PermCoin Hacktool> attack full

Challenge 7 complete, chosen collisions prefixed!

Challenge 8 complete, state optimally optimized!

Full attack complete!
hard flag here
